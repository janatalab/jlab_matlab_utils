function outdata = ensemble_physio_adjust(indata,params)

% manual inspection and adjustment of physio waveforms and peaks
% 
%   outdata = ensemble_physio_adjust(indata,params)
% 
% this script takes physiological data generated by either ensemble_physio
% or ensemble_physio_summ and imports each given signal into
% manual_adjust_signal_data, which allows for artifact correction and peak
% rejection of provided signals. The data returned from
% manual_adjust_signal_data is then re-packaged and returned as outdata
% from this script. Essentially, this script is a wrapper for
% manual_adjust_singal_data.
% 
% REQUIRES
%   indata - an ensemble data struct containing one or many of the
%       following sub-structs:
%       - 'physio_paths'
%       - 'gsr_epochs'
%       - 'cardiac_epochs'
%   params.manual_adjust_signal_data - parameters sent to
%       manual_adjust_signal_data
%   params.manual_adjust_signal_data.samplingRate - if not sampling rate is
%       provided within the input dataset, this sampling rate will be used
% 
% OUTPUT
%   outdata - structures provided within indata, after having been
%       processed by manual_adjust_signal_data
% 
% FB 2009.06.19

if (iscell(indata) && ~isempty(indata) && ...
        isfield(indata{1},'task') && ...
        ~isempty(strmatch('return_outdir',indata{1}.task))) || ...
        (isstruct(indata) && isfield(indata,'task') && ...
        ~isempty(strmatch('return_outdir',indata.task)))
  outdata = '';
  return
elseif ~isstruct(params) || ...
        ~isfield(params,'ensemble_jobman_interactive') ...
        || ~params.ensemble_jobman_interactive
  outdata = '';
  error('please run within an interactive session');
end

outdata = ensemble_init_data_struct();

global r

r = init_results_struct;

r.type = 'physio_summ';  % Identify the type of this reporting instance
r.report_on_fly = 1;

% convert to cell if needed
if isstruct(indata), indata = {indata}; end

try masdp = params.manual_adjust_signal_data; catch masdp = struct(); end

% iterate over indata indices
for in=1:length(indata)
  % get indata
  if isfield(indata{in},'type')
    switch indata{in}.type
      case {'gsr_epoch','cardiac_epoch','gsr_epochs','cardiac_epochs'}
        % load data
        data = indata{in};
        cols = set_var_col_const(data.vars);
        
        % init vars
        if ~isfield(cols,'signal')
          warning('no signal variable for indata %d, SKIPPING',in);
          continue
        else
          signals = data.data{cols.signal};
          ne = length(signals);
        end
        
        if isfield(cols,'srate')
          srates = data.data{cols.srate};
        elseif ~isfield(params,'srate')
          srates = repmat(params.srate,ne,1);
        else
          warning('no sampling rate for indata %d, SKIPPING',in);
          continue
        end
        
        if isfield(cols,'pidxs')
          peaks = data.data{cols.pidxs};
          pcol = 'pidxs';
        elseif isfield(cols,'peakidxs')
          peaks = data.data{cols.peakidxs};
          pcol = 'peakidxs';
        else
          peaks = cell(ne,1);
          pcol = '';
        end

        if ~isfield(cols,'subject_id')
          warning('no subject info in indata %d',in);
          subids = [];
        else
          subids = data.data{cols.subject_id};
        end

        % iterate over epochs
        for ie=1:ne
          % set sampling rate
          masdp.samplingRate = srates(ie);
          if ~isempty(subids)
            vars = {sprintf('subject: %s, epoch %1.0f',subids{ie},ie)};
          else
            vars = {sprintf('epoch %1.0f',ie)};
          end

          % edit epoch
          [lsig,lpeaks] = manual_adjust_signal_data('signal',signals{ie},...
              'peaks',peaks(ie),'params',masdp,'vars',vars);
          
          % repack data
          data.data{cols.signal}{ie} = lsig;
          if ~isempty(pcol)
            data.data{cols.(pcol)}{ie} = lpeaks;
          end
        end

        outdata.vars = [outdata.vars data.type];
        outdata.data = [outdata.data data];
      case {'physio_paths'}
        warning('this option is not yet supported, SKIPPING');
      otherwise
        warning('unknown type %s, SKIPPING',indata{in}.type);
    end % switch indata{in}.type
  end % if isfield(indata{in},'type
end % for in=1:length(indata
